---
# Ansible tasks to enforce cloud-init configuration
# This ensures the server configuration matches what was set up during cloud-init

- name: Set timezone to Europe/Paris
  ansible.builtin.timezone:
    name: Europe/Paris
  become: true

- name: Update package cache
  ansible.builtin.apt:
    update_cache: true
    cache_valid_time: 3600
  become: true

- name: Upgrade all packages
  ansible.builtin.apt:
    upgrade: dist
  become: true

- name: Install essential packages
  ansible.builtin.apt:
    name: "{{ essential_packages }}"
    state: present
  become: true

- name: Check if /dev/sdb exists
  ansible.builtin.stat:
    path: /dev/sdb
  register: sdb_exists

- name: Check if /dev/sdb1 partition exists
  ansible.builtin.stat:
    path: /dev/sdb1
  register: sdb1_exists
  when: sdb_exists.stat.exists

- name: Get partition information for /dev/sdb
  ansible.builtin.parted:
    device: /dev/sdb
    unit: MiB
  register: sdb_info
  become: true
  when: sdb_exists.stat.exists

- name: Set up disk partition on /dev/sdb
  ansible.builtin.parted:
    device: /dev/sdb
    number: 1
    state: present
    part_type: primary
    fs_type: ext4
  become: true
  when: 
    - sdb_exists.stat.exists
    - not sdb1_exists.stat.exists or sdb_info.partitions | length == 0

- name: Check if /dev/sdb1 has ext4 filesystem
  ansible.builtin.command:
    cmd: blkid -s TYPE -o value /dev/sdb1
  register: sdb1_fstype
  failed_when: false
  changed_when: false
  when: sdb_exists.stat.exists and sdb1_exists.stat.exists

- name: Create ext4 filesystem on /dev/sdb1
  ansible.builtin.filesystem:
    fstype: ext4
    dev: /dev/sdb1
    opts: -L data
  become: true
  when: 
    - sdb_exists.stat.exists
    - sdb1_exists.stat.exists
    - sdb1_fstype.stdout != "ext4"

- name: Create /data mount point
  ansible.builtin.file:
    path: /data
    state: directory
    mode: '0755'
  become: true

- name: Mount /data partition
  ansible.builtin.mount:
    path: /data
    src: /dev/sdb1
    fstype: ext4
    opts: defaults,noatime
    dump: 0
    passno: 2
    state: mounted
  become: true
  when: sdb_exists.stat.exists

- name: Ensure ansible user exists
  ansible.builtin.user:
    name: ansible
    comment: "Ansible automation account"
    groups: sudo
    shell: /bin/bash
    state: present
  become: true

- name: Add ansible user to sudoers (NOPASSWD)
  ansible.builtin.lineinfile:
    path: /etc/sudoers.d/ansible
    line: "ansible ALL=(ALL) NOPASSWD:ALL"
    create: true
    mode: '0440'
    validate: 'visudo -cf %s'
  become: true

- name: Set up authorized keys for ansible user
  ansible.posix.authorized_key:
    user: ansible
    key: "{{ ansible_ssh_public_keys | join('\n') }}"
    state: present
  become: true
  when: ansible_ssh_public_keys is defined

- name: Ensure docker group exists
  ansible.builtin.group:
    name: docker
    state: present
  become: true

- name: Ensure admin user exists
  ansible.builtin.user:
    name: "{{ admin_username }}"
    comment: "Primary administrator"
    groups: sudo,docker
    shell: /bin/bash
    state: present
  become: true
  when: admin_username is defined

- name: Add admin user to sudoers (NOPASSWD)
  ansible.builtin.lineinfile:
    path: "/etc/sudoers.d/{{ admin_username }}"
    line: "{{ admin_username }} ALL=(ALL) NOPASSWD:ALL"
    create: true
    mode: '0440'
    validate: 'visudo -cf %s'
  become: true
  when: admin_username is defined

- name: Set up authorized keys for admin user
  ansible.posix.authorized_key:
    user: "{{ admin_username }}"
    key: "{{ admin_ssh_public_keys | join('\n') }}"
    state: present
  become: true
  when: admin_username is defined and admin_ssh_public_keys is defined

- name: Configure SSH hardening
  ansible.builtin.template:
    src: sshd_config.j2
    dest: /etc/ssh/sshd_config.d/90-custom.conf
    owner: root
    group: root
    mode: '0644'
  become: true
  notify: restart ssh

- name: Configure Fail2Ban for custom SSH port
  ansible.builtin.template:
    src: fail2ban_ssh.j2
    dest: /etc/fail2ban/jail.d/ssh.conf
    owner: root
    group: root
    mode: '0644'
  become: true
  notify: restart fail2ban

- name: Build desired rules list
  set_fact:
    firewall_system_input_rules: >-
      {{ 
        [
            {'protocol': 'tcp', 'destination_port': ssh_port|string, 'jump': 'ACCEPT', 'comment': 'ssh'}
        ]
      }}

# Safety rules in INPUT (never flushed)
- name: INPUT safety rules
  ansible.builtin.iptables:
    chain: INPUT
    in_interface: "{{ item.in_interface | default(omit) }}"
    protocol: "{{ item.protocol | default(omit) }}"
    ctstate: "{{ item.ctstate | default(omit) }}"
    jump: "{{ item.jump | default('ACCEPT') }}"
    comment: "{{ item.comment | default(omit) }}"
  loop: "{{ firewall_input_safety_rules }}"
  become: true

# Our managed chain
- name: Ensure SYSTEM-INPUT exists
  ansible.builtin.iptables:
    chain: SYSTEM-INPUT
    state: present
    chain_management: true
  become: true

# INPUT -> SYSTEM-INPUT (append so Fail2Ban f2b-* stays first)
- name: Ensure INPUT jumps to SYSTEM-INPUT
  ansible.builtin.iptables:
    chain: INPUT
    jump: SYSTEM-INPUT
    action: append
    state: present
    comment: system-firewall
  become: true

# --- Build desired rules into a temp chain (for canonical compare)
- name: Ensure temp chain exists
  ansible.builtin.iptables:
    chain: SYSTEM-INPUT-DESIRED
    state: present
    chain_management: true
  changed_when: false
  become: true

- name: Flush temp chain
  ansible.builtin.iptables:
    chain: SYSTEM-INPUT-DESIRED
    flush: yes
  changed_when: false
  become: true

- name: Populate temp chain
  include_tasks: iptables_rules.yaml
  vars:
    target_chain: SYSTEM-INPUT-DESIRED
    rules: "{{ firewall_system_input_rules }}"
    rules_dry_run: true

- name: Get live rules (canonical)
  command: bash -lc "iptables -S SYSTEM-INPUT"
  register: live_rules
  changed_when: false
  become: true

- name: Get desired rules (canonical from temp)
  command: bash -lc "iptables -S SYSTEM-INPUT-DESIRED | sed -E 's/-DESIRED//'"
  register: desired_rules
  changed_when: false
  become: true

# Only if drift: flush & re-populate real chain using the SAME iptables_rules.yaml
- name: Reconcile drift in SYSTEM-INPUT
  when: live_rules.stdout != desired_rules.stdout
  block:
    - name: Flush SYSTEM-INPUT
      ansible.builtin.iptables:
        chain: SYSTEM-INPUT
        flush: yes
      changed_when: true
      become: true

    - name: Re-populate real chain
      include_tasks: iptables_rules.yaml
      vars:
        target_chain: SYSTEM-INPUT
        rules: "{{ firewall_system_input_rules }}"

# Cleanup temp chain
- name: Flush temp chain
  ansible.builtin.iptables:
    chain: SYSTEM-INPUT-DESIRED
    flush: yes
  changed_when: false
  ignore_errors: true  # ok if it doesn't exist
  become: true

- name: Drop temp chain
  command: iptables -X SYSTEM-INPUT-DESIRED
  register: drop_tmp
  failed_when: drop_tmp.rc not in [0,1]
  changed_when: false
  become: true

# Policy after rules exist
- name: INPUT policy DROP
  ansible.builtin.iptables:
    chain: INPUT
    policy: DROP
  become: true

# --- Persistence at boot (rendered from the same vars for zero duplication) ---
- name: Install boot restore file
  template:
    src: system.v4.boot.j2
    dest: /etc/iptables/system.v4.boot
    mode: '0644'
  become: true

- name: Install systemd unit
  template:
    src: system-firewall-restore.service.j2
    dest: /etc/systemd/system/system-firewall-restore.service
    mode: '0644'
  become: true

- name: Reload systemd & enable unit
  systemd:
    daemon_reload: true
    name: system-firewall-restore
    enabled: true
  become: true

- name: Ensure SSH service is running and enabled
  ansible.builtin.systemd:
    name: ssh
    state: started
    enabled: true
  become: true

- name: Ensure Fail2Ban service is running and enabled
  ansible.builtin.systemd:
    name: fail2ban
    state: started
    enabled: true
  become: true



- name: Keyring dir
  file:
    path: /etc/apt/keyrings
    state: directory
    mode: '0755'
  become: true

- name: Docker APT GPG key
  get_url:
    url: https://download.docker.com/linux/ubuntu/gpg
    dest: /etc/apt/keyrings/docker.asc
    mode: '0644'
  become: true

- name: Add Docker APT repo (stable)
  apt_repository:
    repo: >-
      deb [arch=amd64 signed-by=/etc/apt/keyrings/docker.asc]
      https://download.docker.com/linux/ubuntu
      {{ ansible_lsb.codename | default(ansible_distribution_release) }} stable
    filename: docker
    state: present
  become: true

- name: Install Docker Engine (latest stable)
  apt:
    name:
      - docker-ce
      - docker-ce-cli
      - containerd.io
      - docker-buildx-plugin
      - docker-compose-plugin
    state: present
    update_cache: yes
  become: true

- name: Enable & start Docker
  systemd:
    name: docker
    enabled: true
    state: started
  become: true
